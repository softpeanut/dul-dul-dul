# 정리

> 바운디드 컨텍스트는 독립적이지 않고 서로 상호작용 해야 하며 컨텍스트 맵을 통해 표현한다.



바운디드 컨텍스트 패턴은 모델링도 가능하게 한다.

바운디드 컨텍스트의 모델은 서로 독립적이지만 바운디드 컨텍스트 자체는 독립적이지 않다.

서로 독립적으로 발전할 수 있지만, 상호작용해야 하기 때문에 바운디드 컨텍스트 사이에 항상 접점이 있는데 이를 **컨트랙트(Contract)**라고 부른다.

컨트랙트의 필요성은 바운디드 컨텍스트의 모델과 언어의 차이에서 비롯된다.

바운디드 컨텍스트 간의 연동에 대한 고민은 솔루션 설계에서 평가되고 다뤄져야 한다.

바운디드 컨텍스트 간의 관계와 연동을 정의하는 도메인 주도 설계 패턴은 바운디드 컨텍스트에서 작업하는 팀 간의 협력적 특성에 의해 주도된다.



## 협력형 패턴 그룹

협력형(Cooperation) 그룹의 패턴은 소통이 잘 되는 팀에서 구현된 바운디드 컨텍스트와 관련이 있다.

이 패턴이 적합한 요건은 팀의 커뮤니케이션과 협업의 수준에 있다.



### 파트너십 패턴

파트너십(Partnership) 모델에서 바운디드 컨텍스트 간의 연동은 **애드훅(ad-hoc) 방식**으로 조정한다.

한 팀은 다른 팀에게 API의 변경을 알리고 다른 팀은 충돌 없이 이를 받아들인다.

양 팀은 차이점을 함께 해결하고 가장 적절한 솔루션을 선정한다.

성공적인 연동을 위해 잘 구축된 협업 실무, 높은 수준의 헌신, 팀 간의 잦은 동기화는 필수다.

![image](https://user-images.githubusercontent.com/80632060/183085203-f2a5fc6d-8b5f-49f8-b12d-821be3c3419b.png)



### 공유 커널 패턴

바운디드 컨텍스트가 모델의 경계임에도 불구하고, 하위 도메인의 동일 모델이 여러 바운디드 컨텍스트에서 구현되는 경우가 있다.

공유 커널(Shared Kernel)과 **같은 공유 모델**은 모든 바운디드 컨텍스트의 필요에 따라 설계된다.

예를 들어 권한 모델은 각 바운디드 컨텍스트에서 수정할 수 있고 이 변경은 다른 바운디드 컨텍스트에 영향을 준다.

![image](https://user-images.githubusercontent.com/80632060/183086299-7a510a59-953e-45ac-9ad7-4033eb5e9810.png)

#### 공유 범위

겹치는 형태의 모델은 해당되는 바운디드 컨텍스트의 수명주기도 서로 엮이게 한다.

변경의 연쇄 영향을 최소화하려면 공통으로 구현돼야 하는 **모델의 일부분만 노출**하도록 해야 한다.

공유 커널은 바운디드 컨텍스트 간의 제공될 의도가 있는 연동 관련 컨트랙트와 자료구조만으로 구성해야 한다.

#### 구현

공유 커널에 대한 변경이 생길 때마다 영향을 받는 모든 바운디드 컨텍스트와 연동 테스트를 수행해야 한다.

공유 커널은 모델의 일관성을 유지하기 위해 **지속적으로 통합**해야 한다.

#### 공유 커널을 사용해야 하는 경우

공유 커널 패턴의 적용 여부를 결정하는 가장 중요한 기준은 **중복 비용과 조율 비용의 비율**이다.

공유하는 코드베이스에 대한 변경을 조율하려는 노력보다 공유하는 모델에 대한 변경을 통합할 때 드는 노력의 비율을 비교해야 한다.

통합 비용과 중복 비용의 차이는 모델의 변동성(Volatility)에 달렸다.

변경이 잦을수록 통합 비용이 높아지기 때문에 공유 커널은 핵심 하위 도메인처럼 많이 변하는 하위 도메인에 적용된다.

겹치는 형태의 모델인 공유 커널은 여러 팀이 함께 개발한다.

일반적으로 공유 커널 패턴은 파트너십 패턴을 구현하기 어려울 때나 레거시 시스템을 점진적으로 현대화할 경우 적용할 수 있다.

결국 바운디드 컨텍스트의 연동 컨트랙트를 명시적으로 정의하는데 공유 커널 패턴을 사용할 수 있다.



## 사용자-제공자 패턴 그룹

사용자-제공자(Customer-Supplier) 패턴 그룹은 **서비스 제공자(업스트림, Upstream)**와 **고객 또는 사용자(다운스트림, Downstream)**으로 구분된다.

업스트림과 다운스트림은 서로 독립적으로 성장할 수 있지만 연동 컨트랙트를 주도하는 권력의 불균형이 존재한다.

![image](https://user-images.githubusercontent.com/80632060/183089267-6a6f1fda-cd87-45c2-8311-8decc228041e.png)

### 순응주의자 패턴

다운스트림이 **업스트림의 모델을 받아들이는** 바운디드 컨텍스트의 관계를 순응주의자(Conformist) 패턴이라고 부른다.

이 패턴은 힘의 균형이 서비스를 제공하는 업스트림에 치우쳐 있다.

![image](https://user-images.githubusercontent.com/80632060/183090713-f488e84f-e395-46ce-b504-66e75a76cf85.png)

이는 조직 외부의 서비스 제공자와 연동하는 경우 또는 조직의 정치적 이유에서 발생할 수 있다.

업스트림이 노출한 컨트랙트가 산업 표준이거나 잘 구축된 모델 또는 다운스트림의 요건에 충분하다면 자율성의 일부를 포기할 수 있다.



### 충돌 방지 계층 패턴

힘의 균형이 업스트림에 치우쳐 있을 때 다운스트림 바운디드 컨텍스트가 업스트림에 순응하지 않을 경우 충돌 방지 계층을 통해 업스트림의 모델을 **스스로에 맞게 가공**할 수 있다.

충돌 방지 계층(ACL, Anti-Corruption Layer) 패턴은 제공자의 모델을 따르는 것을 원하지 않거나 순응에 필요한 노력이 가치 없을 경우 다룬다.

**다운스트림 바운디드 컨텍스트가 핵심 하위 도메인을 포함할 경우**

핵심 하위 도메인은 제공자의 모델이 자칫 문제 도메인에 대한 모델링을 방해할 수 있다.

**업스트림 모델이 사용자의 요건에 비효율적이거나 불편한 경우**

바운디드 컨텍스트가 혼란에 순응하면 그 자체로 위험에 빠지게 된다.

**제공자가 컨트랙트를 자주 변경하는 경우**

사용자는 잦은 변경으로부터 모델을 보호하기를 원한다.

![image](https://user-images.githubusercontent.com/80632060/183093585-6f9dd933-a555-4257-950b-a135045b676d.png)

### 오픈 호스트 서비스 패턴

오픈 호스트 서비스(OHS, Open-Host Service) 패턴은 충돌 방지 계층 패턴의 반대로 사용자 대신 **제공자가 내부 모델 번역**을 구현한다.

이 패턴은 제공자는 사용자를 보호하는 데 관심이 있고 힘의 균형이 사용자 측에 치우쳐 있다.

구현 모델의 변경으로부터 사용자를 보호하기 위해 퍼블릭 모델과 내부 구현 모델을 분리한다.

![image](https://user-images.githubusercontent.com/80632060/183095144-5f987d25-d1c0-4266-a45f-3e017165d6fc.png)

퍼블릭 인터페이스는 자신의 유비쿼터스 언어를 따르는 것이 아닌, **연동 지향 언어(Integration-Oriented Language)**를 통해 사용자의 편의를 고려한다.

이러한 퍼블릭 프로토콜을 **공표된 언어(Published Language)**라고 한다.

연동 모듈을 분리하면 제공자는 다운스트림 컨텍스트와 상관 없이 자유롭게 구현이 가능하고 공표된 언어의 여러 버전을 동시에 노출해 사용자가 점진적으로 이관할 수 있게 한다.

![image](https://user-images.githubusercontent.com/80632060/183096959-eab480f0-f52c-4a09-9fba-b3a661b5c689.png)



## 분리형 노선

분리형 노선(Separated Ways) 패턴은 **전혀 협력하지 않는 것**이다.



### 커뮤니케이션 이슈

협업을 피하는 일반적인 이유는 커뮤니케이션의 어려움이다.

이런 경우 여러 바운디드 컨텍스트에서 기능을 중복해서 구현하는 것이 더 효과적이다.



### 일반 하위 도메인

일반 하위 도메인이 일반 솔루션과 연동하는 것이 쉽다면 각 바운디드 컨텍스트 내에서 각자 연동하는 것이 더 효과적일 수 있다.

예를 들어 로깅 프레임워크처럼 기능 중복이 없을 경우보다 솔루션을 연동했을 때 복잡성이 커진다면 이를 서비스로 노출하는 것은 바람직하지 않다.



### 모델의 차이

모델이 너무 달라서 순응주의자 관계가 불가능하고, 충돌 방지 계층을 구현하는 것도 기능 중복보다 효과적이지 않을 수 있다.



> 핵심 하위 도메인을 연동할 경우에는 분리형 노선은 피해야 한다.
>
> 하위 도메인의 중복 구현은 회사의 전략을 효과적이고 효율적으로 구현하는 것을 어렵게 한다.



## 컨텍스트 맵

컨텍스트 맵은 시스템의 바운디드 컨텍스트와의 연동을 시각적으로 표현하여 다음과 같은 효과를 얻을 수 있다.

**거시적 설계 관점**

시스템의 구성요소와 구현하는 모델의 개요를 제공한다.

**커뮤니케이션 패턴**

시스템 구성요소 간의 어떠한 연동 패턴을 선호하는지 보여준다.

**조직적 문제**

조직적 문제에 대한 통찰력을 제공한다.

![image]



### 유지보수

컨텍스트 맵은 프로젝트 초기부터 도입해서 기존 요소에 대한 수정을 반영하는 것이 이상적이다.

각 팀은 자신이 담당하는 외부 바운디드 컨텍스트 연동에 대해 갱신한다.

컨텍스트 맵은 컨텍스트 매퍼(Context Mapper) 같은 도구를 사용해 코드로 관리할 수 있다.



### 한계

여러 하위 도메인에 걸친 시스템의 바운디드 컨텍스트에는 다음과 같은 여러 연동 패턴이 있을 수 있다.

바운디드 컨텍스트가 단일 하위 도메인을 가지더라도 여러 연동 패턴이 있을 수 있다.

![image](https://user-images.githubusercontent.com/80632060/183110785-384d4e2b-bae0-4304-a459-597621ba1786.png)





## 결론

바운디드 컨텍스트는 독립적이지 않고 서로 상호작용 해야 한다.

**파트너십**

>  바운디드 컨텍스트는 애드혹 방식으로 연동된다.

**공유 커널**

> 두 개 이상의 바운디드 컨텍스트가 참여하는 모든 바운디드 컨텍스트가 공유하는 제한적으로 겹치는 모델을 공유해서 연동한다.

**순응주의자**

> 사용자는 서비스 제공자의 모델에 순응한다.

**충돌 방지 계층**

> 사용자는 서비스 제공자의 모델을 사용자의 요건에 맞게 번역한다.

**오픈 호스트 서비스**

> 서비스 제공자는 사용자의 요건에 최적화된 모델인 공표된 언어를 구현한다.

**분리형 노선**

> 협력과 연동보다 특정 기능을 중복으로 두는 것이 더 저렴한 경우다.

바운디드 컨텍스트 간의 연동은 컨텍스트 맵으로 표현되며 이를 통해 시스템의 거시적 설계 관점, 커뮤니케이션 패턴, 조직 문제에 대한 통찰력을 얻을 수 있다.



# 느낀점

간단하게 이벤트 스토밍을 해보며 마무리 단계에 이르렀을 때 바운디드 컨텍스트를 분리하고 서로의 관계를 파악해 컨텍스트 매핑하는 작업을 했었다.

그 과정에서 명확하게 어떠한 기준으로 해야하는지, 어떤 경우에 어떠한 연동 패턴이 사용되는지 헷갈렸는데 확실하게 개념을 잡을 수 있었다.

다음과 같이 일반적으로 사용되는 연동 패턴을 나타낼 수 있을 것 같다.

- 핵심 하위 도메인 - 충돌 방지 계층
- 일반 하위 도메인 - 오픈 호스트 서비스, 공유 커널
- 지원 하위 도메인 - 오픈 호스트 서비스, 충돌 방지 계층