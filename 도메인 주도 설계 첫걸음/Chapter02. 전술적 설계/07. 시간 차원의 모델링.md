# 정리

> 이벤트 소싱 도메인 모델 패턴은 도메인 이벤트를 통해 모든 변경사항을 기록한다.



이벤트 소싱 도메인 모델 패턴은 도메인 모델 패턴과 동일한 전제를 기반으로 하며 동일한 전술적 패턴을 사용한다.

하지만 이벤트 소싱 도메인 모델 패턴은 애그리거트의 상태를 유지하는 대신 각 변경사항을 설명하는 **도메인 이벤트**를 생성한다.



## 이벤트 소싱

> 순서도만 보여주고 테이블을 숨기면 상대가 계속 어리둥절할 것이다.
> 테이블을 보여주면 일반적으로 순서도는 필요 없게 된다.
> 테이블의 정보만으로도 명백하기 때문이다.



일반적인 테이블은 식별자 ID, 기본적인 정보, 현재 상태 등 다양한 정보를 수집할 수 있고 데이터 모델링에 어떤 유비쿼터스 언어가 사용되었는지 추측할 수도 있다.

하지만 현재 상태가 아닌 현재 상태에 이르기까지의 과정을 알 수는 없다.

이벤트 소싱 패턴은 데이터 모델에 **시간 차원**을 도입해 애그리거트의 모든 변경사항을 문서화하는 이벤트를 유지한다.

다음과 같이 고객의 상태를 이런 도메인 이벤트로부터 쉽게 **프로젝션**할 수 있다.

```json
[
    {
        "lead-id": 12,
        "event-id": 0,
        "event-type": "lead-initialized",
        "first-name": "Casey",
        "last-name": "David",
        "phone-number": "555-2951",
        "timestamp": "2020-05-20T09:52:55.95Z"
    },
    {
        "lead-id": 12,
        "event-id": 1,
        "event-type": "contacted",
        "timestamp": "2020-05-20T12:32:08.24Z"
    },
    {
        "lead-id": 12,
        "event-id": 2,
        "event-type": "followup-set",
        "followup-on": "2020-05-27T12:00:00.00Z",
        "timestamp": "2020-05-20T12:32:08.24Z"
    },
    {
        "lead-id": 12,
        "event-id": 3,
        "event-type": "contact-details-updated",
        "first-name": "Casey",
        "last-name": "Davis",
        "phone-number": "555-8101",
        "timestamp": "2020-05-20T12:32:08.24Z"
    },
    {
        "lead-id": 12,
        "event-id": 4,
        "event-type": "contacted",
        "timestamp": "2020-05-27T12:02:12.51Z"
    },
    {
        "lead-id": 12,
        "event-id": 5,
        "event-type": "order-submitted",
        "payment-deadline": "2020-05-30T12:02:12.51Z",
        "timestamp": "2020-05-27T12:02:12.51Z"
    },
    {
        "lead-id": 12,
        "event-id": 6,
        "event-type": "payment-confirmed",
        "status": "converted",
        "timestamp": "2020-05-27T12:38:44.12Z"
    }
]
```

- 이벤트 0 - 리드는 시스템에서 생성되었다.
- 이벤트 1 - 약 2시간 후에 영업 담당자가 연락했다.
- 이벤트 2 - 통화 중에 영업 담당자가 일주일 후 연락하기로 했다.
- 이벤트 3 - 일주일 후 다른 전화번호로 다시 연락하기로 했고, 영업 담당자가 성의 오타를 수정했다.
- 이벤트 4 - 리드는 약속된 날짜와 시간에 연락을 했다.
- 이벤트 5 - 주문을 제출했고, 주문은 3일 이내 결제 예정이었다.
- 이벤트 6 - 약 30분 후에 결제가 완료되어 리드가 신규 고객으로 전환되었다.

이벤트를 표현할 때 버전을 관리해 모든 변경 횟수를 나타내는데, 이를 통해 원하는 지점의 고객 상태를 프로젝션할 수 있다.



### 검색

변경된 내용을 검색하는 사람이 인지하지 못할 경우 이벤트 소싱을 사용해 상태에 영향을 미치지 않고 다음과 같이 과거 정보를 쉽게 프로젝션할 수 있다.

```
LeadId: 12
FirstNames: ['David', 'Davis']
LastNames: ['555-2951', '555-8101']
Version: 6
```



### 분석

조금 더 분석하기 편한 데이터를 얻기 위해 특정 모델을 사용해 영업 프로세스를 최적화하려고 할 수 있다.

또한 검색 최적화와 분석 최적화 모델을 메모리에서 프로젝션하는 것이 아닌 프로젝션된 모델을 데이터베이스에 유지해야 한다.



### 원천 데이터

이벤트 소싱 패턴이 작동하려면 객체 상태에 대한 모든 변경사항이 이벤트로 표현되고 저장되어야 한다.

이러한 이벤트는 시스템의 원천 데이터가 되며, 이벤트를 저장하는 데 사용되는 데이터베이스를 **이벤트 스토어(Event Store)**라고 지칭한다.

![image](https://user-images.githubusercontent.com/80632060/183290321-d84027f5-2cc2-4278-9975-ff3f734e244c.png)

### 이벤트 스토어

이벤트 스토어는 추가만 가능한 저장소이므로 특정 비즈니스 엔티티에 속한 모든 이벤트를 가져오고 이벤트를 추가하는 기능을 지원해야 한다.

엔티티 버전을 지정해 낙관적 동시성 제어를 구현할 때 사용할 수 있다.



## 이벤트 소싱 도메인 모델

도메인 모델은 애그리거트의 상태 표현 방식을 유지 관리하지만 이벤트 소싱 도메인 모델은 애그리거트의 **생명주기를 모델링**하는 도메인 이벤트를 사용한다.

이벤트 소싱 애그리거트는 다음과 같은 과정을 따라 작업된다.

- 애그리거트의 도메인 이벤트를 로드한다.
- 이벤트를 비즈니스 의사결정을 내리는 데 사용할 수 있는 상태로 프로젝션해서 상태 표현을 재구성한다.
- 애그리거트의 명령을 실행하여 비즈니스 로직을 실행하고 결과적으로 새로운 도메인 이벤트를 생성한다.
- 새 도메인 이벤트를 이벤트 스토어에 커밋한다.

애플리케이션 서비스 위와 같은 과정에 따른다.



### 장점

**시간 여행**

> 도메인 이벤트를 사용해 애그리거트의 현재 상태를 재구성할 수 있는 것처럼 애그리거트의 모든 과거 상태를 복원하는 데도 사용할 수 있다.
>
> 과거 상태를 재구성하는 또 다른 유스케이스는 소급 디버깅(Retroactive Debugging)이다.

**심오한 통찰력**

> 이벤트 소싱은 시스템의 상태와 동작에 대한 깊은 통찰력을 제공한다.
>
> 이벤트를 다른 상태 표현 방식으로 변환할 수 있는 유연한 모델을 제공해 새로운 프로젝션 방법을 언제든지 추가할 수 있다.

**감사 로그**

> 영속적인 도메인 이벤트는 애그리거트 상태에 발생한 모든 것에 대한 일관된 감사 로그(Audit Log)를 나타낸다.
>
> 이를 통해 시스템의 의사결정과 계정 간의 흐름을 쉽게 추적할 수 있다.

**고급 낙관적 동시성 제어**

> 읽기 데이터가 기록되는 동안 다른 프로세스에 의해 덮어 쓰여지는 경우 예외를 발생시킨다.
>
> 이벤트 스토어에 동시에 추가된 이벤트를 추출하고 새로운 이벤트가 작업과 충돌하는지, 계속 진행하는 것이 안전한지에 대해 비즈니스 도메인 주도 의사결정을 내릴 수 있다.



### 단점

**학습 곡선**

> 기존 기술과 엄청난 차이가 있기 때문에 새로운 사고 방식에 익숙해지는 시간이 필요하다.

**모델의 진화**

> 이벤트 소싱의 정의를 엄밀하게 따지면 이벤트는 변경할 수 없다.
>
> 이벤트의 스키마를 조정해야 하는 경우 복잡한 과정을 통해 변경해야 한다.

**아키텍처 복잡성**

> 이벤트 소싱을 구현하면 수많은 아키텍처의 '유동적인 부분'이 도입되어 전체 설계가 더 복잡해진다.



## 자주 묻는 질문

### 성능

> 이벤트에서 애그리거트 상태를 재구성하면 시스템 성능에 부정적인 영향을 준다. 이벤트가 추가되면서 성능이 저하된다. 이것이 어떻게 작동할 수 있을까?

이벤트를 상태 표현 방식으로 프로젝션하려면 컴퓨팅 성능이 필요하며 이벤트가 많아질수록 그 필요성은 더 커진다.

프로젝션 과정이 미치는 **이벤트 작업 효과를 벤치마킹**하는 것이 중요하다.

대부분의 시스템에서 애그리거트당 10,000개 이상의 이벤트가 있을 경우 성능이 크게 저하되지만 평균적인 애그리거트 이벤트는 100개를 넘지 않는다.

성능을 위해 적용에 대한 당위성 증명이 필요한 최적화 과정인 **스냅샷 패턴** 같은 다른 패턴을 적용할 수도 있다.

![image]



> 이 모델은 엄청난 양의 데이터를 생성한다. 확장할 수 있을까?

모든 작업은 단일 애그리거트 컨텍스트에서 수행되므로 이벤트 스토어는 애그리거트 ID로 분할할 수 있다.

애그리거트의 인스턴스에 속하는 모든 이벤트는 **단일 샤드(Shard)**에 있어야 한다.

![image]



### 데이터 삭제

> 이벤트 스토어는 추가 전용 데이터베이스지만 물리적으로 데이터를 삭제해야 하는 경우에는 어떻게 할까? 예를 들어, GDPR을 준수하기 위해 물리적으로 데이터 삭제가 필요하다.

이런 요구사항은 **잊어버릴 수 있는 페이로드 패턴(Forgettable Payload Pattern)**으로 해결할 수 있다.

즉, 모든 민감한 정보는 암호화된 형식으로 이벤트에 포함되고 외부 키-값 저장소에 암호화 키를 저장한다.



### 이렇게 하면 안될까요...?

> 텍스트 파일에 로그를 작성하여 감사 로그를 사용할 수 없는 이유는 무엇일까?

실시간 데이터 처리 데이터베이스(Operational Database)와 로그 파일 모두에 데이터를 쓰는 것은 오류가 발생하기 쉬운 작업이다.

데이터베이스 트랜잭션이 실패하면 이전 로그 메시지를 삭제하지 않기 때문에 일관성이 없어진다.



> 상태 기반 모델을 계속 사용할 수 없지만 동일한 데이터베이스 트랜잭션에서 로그를 로그 테이블에 추가할 수 없는 이유는 무엇일까?

인프라 관점에서 이 접근 방식은 상태와 코드 레코드 간의 일관된 동기화를 제공한다.

상태 기반 표현 방식을 원천 데이터로 사용할 때 추가 로그 테이블의 스키마가 모든 필수 정보가 올바른 형식으로 작성되도록 강제할 방법은 없다.



> 상태 기반 모델을 계속 사용할 수 없지만 레코드의 스냅샷을 만들어 전용 '이력' 테이블에 복사하는 데이터베이스 트리거를 추가할 수 없는 이유는 무엇일까?

로그 테이블에 레코드를 추가하기 위해 명시적으로 수동 호출이 필요하지 않다.

결과 기록에는 어떤 필드가 변경되었는지에 대한 사실만 포함되고 '왜' 필드가 변경되었는지와 같은 비즈니스 컨텍스트를 잃게 된다.



## 결론

이벤트 소싱 도메인 모델 패턴에서 애그리거트 상태에 대한 모든 변경사항은 도메인 이벤트로 표현한다.

결과 도메인 이벤트는 애그리거트의 현재 상태를 프로젝션하거나 여러 표현 모델로 프로젝션할 수 있는 유연성을 제공한다.

분석과 최적화를 하거나 감사 로그가 필수적이어서 시스템 데이터에 대한 심오한 통찰력이 필요한 경우 적합하다.



# 느낀점

이벤트 소싱이 무엇이고 이벤트 소싱을 하는 전반적인 방법에 대해 알게되었다.

모든 변경사항을 이벤트로 처리하여 쉽게 프로젝션할 수 있고 시간의 흐름을 알 수 있다.

하지만 이벤트 기반으로 처리하는 것이 많은 장점이 있지만 학습 곡선이 높고 아키텍처가 기존 방식에 비해 복잡해진다.

기본적인 작업이 아닌 최적화가 필요하고 고도화된 작업이 이루어지거나 모든 변경사항을 알아야할 때 사용하면 좋을 것 같다.

필요한 경우 도전해볼만한 가치가 있는 것 같다.
