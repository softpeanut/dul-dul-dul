# 정리

> 단순한 비즈니스 로직을 처리하기 위해 트랜잭션 스크립트 패턴, 액티브 레코드 패턴을 사용할 수 있다.



## 트랜잭션 스크립트

> 프레젠테이션으로부터 단일 요청을 처리하는 여러 프로시저를 모아서 비즈니스 로직을 구현해야 한다.



시스템의 퍼블릭 인터페이스는 사용자가 실행할 수 있는 비즈니스 트랜잭션의 모음으로 볼 수 있다.

트랜잭션 스크립트 패턴은 **프로시저를 기반**으로 시스템의 비즈니스 로직을 구성한다.

또한 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현한다.



### 구현

각 프로시저는 간단하고 쉬운 절차지향 스크립트(Procedural Script)로 구현한다.

프로시저가 구현해야 하는 유일한 요구사항은 트랜잭션 동작이며, 각 작업은 성공하거나 실패할 수 있지만 유효하지 않은 상태를 만들면 안 된다.

작업이 실패한다면 변경사항을 롤백하거나 보상 조치를 실행하여 **일관성을 유지**해야 한다.



### 그렇게 쉽진 않다!

트랜잭션 스크립트 패턴은 **고급 비즈니스 로직 구현 패턴의 기반**이 된다.

수많은 운영 시스템 문제는 비즈니스 로직에서 트랜잭션 동작을 잘못 구현해서 발생한다.

#### 트랜잭션 동작 구현 실패

전체를 아우르는 트랜잭션 없이 여러 업데이트를 하는 경우 트랜잭션 동작 구현에 실패한다.

다음과 같이 Users 테이블이 업데이된 후 네즈워크 중단, 데이터베이스 시간 초과 또는 교착 상태 등 여러 문제로 VisitsLog 테이블에 레코드가 기록되지 않을 수 있다.

```java
public class LogVisit
{
    // ...

    public void Execute(Guid userId, DataTime visitedOn)
    {
        _db.Execute(“UPDATE Users SET last_visit=@p1 WHERE user_id=@p2”,
            visitedOn, userId);
        _db.Execute(@“INSERT INTO VisitsLog(user_id, visit_date)
                     VALUES(@p1, @p2)”, userId, visitedOn);
    }
}
```

이런 경우 두 데이터 변경을 모두 포함하는 트랜잭션을 만들어서 해결할 수 있다.

하지만 분산 트랜잭션에서 통합할 수 없는 여러 개의 저장 장치로 작업하는 경우에는 더 복잡해진다.

#### 분산 트랜잭션

분산 시스템에서는 데이터베이스의 데이터를 변경한 다음 메시지 버스에 메시지를 발행하여 다른 컴포넌트에 변경사항을 알린다.

```java
public class LogVisit
{
    // ...

    public void Execute(Guid userId, DataTime visitedOn)
    {
        _db.Execute(“UPDATE Users SET last_visit=@p1 WHERE user_id=@p2”,
                   visitedOn,userId);
        _messageBus.Publish(“VISITS_TOPIC”,
                           new { UserId = userId, VisitDate = visitedOn });
    }
}
```

여러 저장 장치에 걸쳐 있는 분산 트랜잭션은 복잡하고 확장하기 어렵고 오류가 발생하기 쉬우므로 일반적으로 피하는 방식이다.

CQRS 아키텍처 패턴, 아웃박스 패턴 등 문제를 해결하는 것은 쉽지 않다.

#### 암시적 분산 트랜잭션

이전과 다르게 마지막 방문 날짜를 추적하는 대신 각 사용자에 대한 방문 카운트를 유지한다.

```java
public class LogVisit
{
    // ...
 
    public void Execute(Guid userId)
    {
        _db.Execute(“UPDATE Users SET visits=visits+1 WHERE user_id=@p1”,
                    userId);
    }
}
```

하지만 메서드 실행은 성공했지만 호출자에게 결과를 전달하는 데 실패하는 경우도 있을 수 있다.

- LogVisit이 REST 서비스의 일부이고 네트워크 중단이 발생한 경우
- LogVisit이 호출자가 동일한 프로세스에서 실행되고 있지만 호출자가 LogVisit 작업의 성공적인 실행을 추적하기 전에 프로세스가 실패하는 경우

이때 로직을 다시 실행하면 카운트 값이 1이 아닌 2로 증가하게 되어 의도와 다른 결과가 나타난다.

이 문제는 작업을 **멱등성(Idempotent)**로 만들어 같은 요청에 대해 매번 동일한 결과를 보장하면 해결할 수 있다.

또 다른 방법으로 **낙관적 동시성 제어(Optimistic Concurrency Control)**를 사용해 해결할 수 있다.



### 트랜잭션 스크립트를 사용하는 경우

트랜잭션 스크립트 패턴은 비즈니스 로직이 ETL(추출-변환-적재) 작업과 같은 단순한 절차적 작업처럼 매우 **간단한 문제 도메인에 효과적**이다.

트랜잭션 스크립트 패턴은 정의상 비즈니스 로직이 단순한 지원 하위 도메인 또는 외부 시스템 연동, 충돌 방지 계층의 일부로 사용할 수도 있다.

최소한의 추상화를 도입하여 런타임 성능을 최적화하고, 비즈니스 로직을 이해하기 위한 시간을 최소화하는 등 단순함이 주요 장점이다.

하지만 핵심 하위 도메인과 같이 비즈니스 로직이 복잡한 경우 대처할 수 없게 된다.



## 액티브 레코드

> 데이터베이스 테이블 또는 뷰의 행을 감싸고 데이터베이스 접근을 캡슐화하고 해당 데이터에 도메인 로직을 추가하는 오브젝트



트랜잭션 스크립트 패턴과 마찬가지로 비즈니스 로직이 단순한 경우 사용한다.

하지만 액티브 레코드는 **복잡한 자료구조**에서도 비즈니스 로직이 작동할 수 있다.



### 구현

결과적으로 이 패턴은 액티브 레코드라고 하는 전용 객체를 사용해 복잡한 자료구조를 표현한다.

이외에 데이터 접근 방법(CRUD)도 구현하기 때문에 액티브 레코드 객체는 **객체 관계 매핑(ORM, Object-Oriented Mapping)**과 관련이 있다.

액티브 레코드는 데이터베이스에 직접 접근하지만 트랜잭션 스크립트는 액티브 레코드를 조작한다는 점이 다르다.

이 패턴의 목적은 메모리 상의 객체를 데이터베이스 스키마에 매핑하는 복잡성을 숨기는 것이다.

영속성을 담당하는 것 외에 필드의 유효성을 검사할 수도 있다.

즉, 액티브 레코드 객체의 고유 기능은 **자료구조와 동작(비즈니스 로직)의 분리**다.



### 액티브 레코드를 사용하는 경우

액티브 레코드는 데이터베이스에 대한 접근을 최적화하는 트랜잭션 스크립트이기 때문에 비교적 간단한 비즈니스 로직만 지원할 수 있다.

트랜잭션 스크립트 패턴과 마찬가지로 지원 하위 도메인, 외부 솔루션 연동, 모델 변환 작업에 적합하다.

액티브 레코드 패턴은 **빈약한 도메인 모델 안티패턴(Anemic Domain Model Anti-Pattern)**으로 부적절하게 설계된 도메인 모델이라고도 부른다.

이 패턴은 도구로서 다른 도구와 마찬가지로 잘못 적용하면 득보다 실이 더 많을 수 있다.

그렇기 때문에 액티브 레코드는 프레임워크가 아닌 디자인 패턴을 의미한다.



## 실용적인 접근 방식

대규모 시스템에서는 데이터의 일관성 보장보다 실용성이 더 중요할 수 있다.

예를 들어, 100만 개 중 하나의 레코드 상태를 손상시키는 것이 실제로 비즈니스에 쇼스토러(Showstopper)가 되는지, 성과와 수익성에 영향을 주는지 확인해야 한다.

어떠한 법칙도 보편적이지 않고 작업 중인 비즈니스 도메인에 따라 달라진다.



## 결론

비즈니스 로직을 구현하기 위해 두 가지 패턴을 사용할 수 있다.

**트랜잭션 스크립트**

> 시스템 작업을 간단하고 쉬운 절차지향 스크립트로 구성한다. 
>
> 작업에 트랜잭션을 적용해서 작업이 성공하거나 실패하도록 보장한다. 
>
> ETL처럼 단순한 비즈니스 로직을 가진 지원 하위 도메인에 적합하다.

**액티브 레코드**

> 비즈니스 로직이 단순하지만 복잡한 자료구조에서 구현할 수 있다. 
>
> 간단한 CRUD 데이터 접근 방법을 제공하는 자료구조다.



# 느낀점

간단한 비즈니스 로직을 처리하기 위해 사용할 수 있는 두 가지 패턴을 알게되었다.

트랜잭션 스크립트 패턴은 작업을 하나의 트랜잭션으로 구성해 무조건 성공하거나 실패하도록 보장한다.

액티브 레코드 패턴은 복잡한 자료구조를 표현할 때 데이터베이스 스키마에 매핑하는 복잡성을 숨긴다.

두 패턴의 공통점은 지원 하위 도메인, 외부 시스템(솔루션)과의 연동, 모델 변환 등 비즈니스 로직이 간단할 경우 사용된다.

ORM과 액티브 레코드의 차이점을 명확하게 깨닫지는 못한 것 같다.