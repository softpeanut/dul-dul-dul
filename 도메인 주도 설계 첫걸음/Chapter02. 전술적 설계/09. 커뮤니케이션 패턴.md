# 정리

> 서로 다른 바운디드 컨텍스트 또는 애그리거트 간 연동이 필요한 경우 모델 변환, 아웃박스 패턴, 사가 패턴 등 다양한 방법을 통해 구현할 수 있다.



## 모델 변환

서로 다른 바운디드 컨텍스트를 구현하는 팀이 효과적으로 의사소통하고 협력할 의향이 있다면 파트너십, 공유 커널을 이용해 해결할 수 있다.

사용자-제공자 관계에서 바운스트림이 업스트림의 모델을 따를 수 없을 때는 한쪽 또는 양쪽 모두에서 ACL과 OHS를 통해 처리할 수 있다.

모델의 변환 로직은 스테이트리스 또는 스테이트풀이 될 수 있다.

**스테이트리스 변환(Stateless Translation)**은 수신(OHS) 또는 발신(ACL) 요청이 발행할 때 즉석에서 발생하지만, **스테이트풀 변환(Stateful Translation)**은 상태 보존을 위해 데이터베이스를 이용한다.



### 스테이트리스 모델 변환

스테이트리스 모델 변환을 소유하는 바운디드 컨텍스트는 **프록시 디자인 패턴(Proxy Design Pattern)**을 구현하여 매핑한다.

![image](https://user-images.githubusercontent.com/80632060/183630185-d05eb426-4606-4b73-a76c-394348cbb6c5.png)

#### 동기

동기식 통신에 사용하는 모델을 변환하는 일반적인 방법은 바운디드 컨텍스트 **코드베이스에 변환 로직을 포함**하는 것이다.

![image](https://user-images.githubusercontent.com/80632060/183630597-c03793fb-6036-490a-8d58-b5f8e7ae38c8.png)

또는 API 게이트웨이 패턴과 같은 외부 컴포넌트를 이용하는 것이 효과적일 수도 있다.

OHS 패턴을 구현하는 경우 API 게이트웨이는 내부 모델을 통합에 최적화된 공표된 언어로 변환하는 역학을 한다.

![image](https://user-images.githubusercontent.com/80632060/183631390-22d56125-d321-4d15-99e3-ea6a0e8073fb.png)

API 게이트웨이를 사용해 구현된 ACL은 통합 관련 바운디드 컨텍스트 역할을 한다.

이런 바운디드 컨텍스트는 **교환 컨텍스트(Interchange Context)**라고도 부른다.

![image](https://user-images.githubusercontent.com/80632060/183631457-458e365e-b2ef-45b0-adc7-7086f207a9ee.png)

#### 비동기

비동기 통신에 사용하는 모델을 변환하기 위해 **메시지 프록시(Message Proxy)**를 구현할 수 있다.

메시지 프록시는 소스 바운디드 컨텍스트에서 오는 메시지를 구독하는 중개 컴포넌트 역할과 관련 없는 메시지를 필터링하는 역할을 한다.

![image](https://user-images.githubusercontent.com/80632060/183632313-71948ee8-a745-4f2d-8891-ef30e77c9916.png)

모델의 객체에 대해 공표된 언어를 설계하고 노출해서 바운디드 컨텍스트의 구현 모델을 노출하면 안된다.

비동기 변환을 사용하면 바운디드 컨텍스트의 구현 상세를 더 잘 캡슐화할 수 있고 내부 요구사항을 위한 프라이빗 이벤트(Private Event)와 다른 바운디드 컨텍스트와 연동하기 위한 퍼블릭 이벤트(Public Event)를 구분할 수 있다.

![image](https://user-images.githubusercontent.com/80632060/183632245-b3e823b6-dddf-41d8-9b9b-9d50bb2df600.png)

### 스테이트풀 모델 변환

원천 **데이터를 집계**하거나 여러 개의 요청에서 들어오는 데이터를 **단일 모델로 통합**해야 하는 변환 메커니즘일 경우 스테이트풀 변환이 필요하다.

#### 들어오는 데이터 집계하기

바운디드 컨텍스트가 들어오는 요청을 집계하고 성능 최적화를 위해 일괄 처리할 경우 동기와 비동기 요청 모두에 대해 집계가 필요할 수 있다.

또 여러 개의 세분화된 메시지를 단일 메시지로 결합해야할 경우 소스 데이터를 집계해야 한다.

유입되는 데이터를 집계하는 모델 변환은 API 게이트웨이를 사용하여 구현할 수 없기 때문에 데이터를 추적하고 처리하려면 변환 로직 자체에 **영구 저장소**가 필요하다.

![image](https://user-images.githubusercontent.com/80632060/183643368-480d0961-0028-4061-9cac-2891a3a94dff.png)

#### 여러 요청 통합

다른 바운디드 컨텍스트를 포함하여 여러  요청에서 집계된 데이터를 처리해야 할 때는 **프론트엔드를 위한 백엔드 패턴(Backend-for-Frontend Pattern)**을 사용할 수 있다.

여러 다른 컨텍스트의 데이터를 처리하고 이를 위해 복잡한 비즈니스 로직을 구현해야 하는 바운디드 컨텍스트에서는 다음과 같이 ACL을 컨텍스트 전면에 배치해 연동과 로직을 분리하는 것이 유리하다.

![image](https://user-images.githubusercontent.com/80632060/183643843-4663f9d3-7874-4516-afd0-f7b29161be2f.png)

## 애그리거트 연동

애그리거트가 시스템의 나머지 부분과 통신하는 방법 중 하나는 도메인 이벤트를 발행하고 외부 컴포넌트가 도메인 이벤트를 구독해 해당 로직을 실행하는 것이다.

애그리거트에서 도메인 이벤트를 직접 발행하는 것은 다음과 같은 이유로 좋지 않다.

- 애그리거트의 새 상태가 데이터베이스에 커밋되기 전에 이벤트가 전달된다.
- 경합 조건, 후속 애그리거트 로직으로 인해 작업이 무효화되거나 기술적인 문제로 인해 트랜잭션이 커밋되지 않으면 이벤트만 전달된다.

도메인 이벤트 발행을 애플리케이션 계층으로 옮겨 트랜잭션을 커밋한 후 도메인 이벤트를 발행할 수도 있다.

하지만 이 역시 트랜잭션이 커밋된 후 도메인 이벤트 발행이 안될 가능성이 있다.



### 아웃박스

아웃박스 패턴은 다음 과정을 통해 도메인 이벤트의 **안정적인 발행을 보장**한다.

- 업데이트 된 애그리거트의 상태와 새 도메인 이벤트는 모두 동일한 원자성 트랜잭션으로 커밋된다.
- 메시지 릴레이는 데이터베이스에서 새로 커밋된 도메인 이벤트를 가져온다.
- 릴레이는 도메인 이벤트를 메시지 버스에 발행한다.
- 성공적으로 발행되면 릴레이는 이벤트를 데이터베이스에 발행한 것으로 표시하거나 완전히 삭제한다.

관계형 데이터베이스를 사용할 때 두 개의 테이블에 원자적으로 커밋하고 메시지를 저장하기 위한 **전용 테이블**을 사용하는 데이터베이스의 기능을 활용하는 것이 좋다.

![image](https://user-images.githubusercontent.com/80632060/183655093-4974b1ab-9644-4c7c-a6dd-43e714950e9b.png)

다중 문서 트랜잭션을 지원하지 않는 NoSQL 데이터베이스를 사용할 때 전달된 도메인 이벤트는 애그리거트 레코드에 포함되어야 한다.

#### 발행되지 않은 이벤트 가져오기

발행 릴레이는 풀(Pull) 기반 또는 푸시(Push) 기반 방식으로 새 도메인 이벤트를 가져온다.

**풀(발행자 풀링)**

> 릴레이는 발행되지 않은 이벤트에 대해 데이터베이스를 지속해서 질의할 수 있다.
>
> 지속적인 풀링으로 인한 부하를 최소화하려면 적절한 인덱스가 필요하다.

**푸시(트랜잭션 로그 추적)**

> 데이터베이스의 기능을 활용해 새 이벤트가 추가될 때마다 발행 릴레이를 호출할 수 있다.



### 사가

핵심 애그리거트 설계 원칙 중 하나는 각 트랜잭션을 애그리거트의 단일 인스턴스로 제한하는 것이다.

하지만 여러 애그리거트에 걸쳐 비즈니스 프로세스를 구현해야 할 경우 **사가(Saga)**로 구현할 수 있다.

사가는 오래 지속되는 비즈니스 프로세스로 관련 컴포넌트에서 발생하는 이벤트를 수신하고 다른 컴포넌트에 후속 커맨드를 실행한다.

실행 단계 중 하나가 실패하면 시스템 상태를 일관되게 유지하도록 **보상 조치**를 내린다.

![image](https://user-images.githubusercontent.com/80632060/183656986-abd210f9-129a-4c28-838b-add563c445ff.png)

상태 관리가 필요한 사가에서 커맨드 실행 로직은 도메인 이벤트가 사가 패턴 자체에서 벗어나 비동기적으로 실행한다.

도메인 이벤트를 발행할 경우 사가 상태 전환을 커맨드 실행과 분리하면 커맨드가 안정적으로 실행될 수 있다.

#### 일관성

사가 패턴이 다중 컴포넌트의 트랜잭션을 조율하기는 하지만 관련된 컴포넌트의 상태는 궁극적으로 일관성을 갖는다.

따라서 부적절한 애그리거트 경계를 보상하기 위해 사가를 남용해서는 안된다.

동일한 애그리거트에 속해야 하는 비즈니스 작업에는 **강한 일관성을 갖는 데이터**가 필요하다.



### 프로세스 관리자

사가 패턴은 단순하고 선형적인 흐름을 관리해 이벤트를 해당 커맨드와 일치시킨다.

프로세스 관리자 패턴은 **비즈니스 로직 기반 프로세스**를 구현하기 위한 것으로, if-else 문을 포함한 동작이라면 대부분 프로세스 관리자이다.

![image](https://user-images.githubusercontent.com/80632060/183659607-79ea243f-3cb4-4b1a-b1e0-e9cf02857259.png)

사가는 특정 이벤트가 관찰될 때 암시적으로 인스턴스화되지만 프로세스 관리자는 단일 소스 이벤트에 바인딩될 수 없어 명시적으로 인스턴스화해야 한다.

프로세스 관리자는 상태 기반 또는 이벤트 소싱의 애그리거트로 구현된다.



## 결론

충돌 방지 계층 또는 오픈 호스트 서비스를 구현하는 데 사용할 수 있는 모델 변환 패턴에는 프록시 디자인 패턴, 메시지 프록시 패턴, 프론트엔드를 위한 백엔드 패턴 등 다양한 패턴이 있다.

**아웃박스 패턴**

>  애그리거트의 도메인 이벤트를 발행하는 안정적인 방법이다.

**사가 패턴**

> 간단한 교차 컴포넌트 비즈니스 프로세스를 구현하는 데 사용된다.

**프로세스 관리자 패턴**

> 좀 더 복잡한 비즈니스 프로세스를 구현할 수 있다.

사가 패턴과 프로세스 관리자 패턴 모두 도메인 이벤트에 대한 비동기식 반응과 커맨드 실행에 의존한다.



# 느낀점

여러 바운디드 컨텍스트 또는 애그리거트 간 연동이 필요한 경우 다양한 방법을 이용해 해결할 수 있다.

업스트림 또는 다운스트림의 모델을 변환하여 통합할 수 있고, 아웃박스와 사가 패턴, 프로세스 관리자 패턴과 같이 도메인 이벤트를 활용해 처리할 수도 있다.

대부분 동일한 흐름에 처리되어야 하는 강한 일관성을 가진 작업은 동일 애그리거트에 두는 것이 맞다.

하지만 동일한 흐름에 처리되는 것도 서로 다른 애그리거트에 위치해 있다면 궁극적인 일관성을 가지기 때문에 무조건 연동을 남용해서는 안된다.
