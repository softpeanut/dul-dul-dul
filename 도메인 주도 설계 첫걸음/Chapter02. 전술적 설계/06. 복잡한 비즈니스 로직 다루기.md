# 정리

> 도메인 모델 패턴을 통해 복잡한 비즈니스 로직을 다룰 수 있다.



## 배경

에릭 에반스는 <도메인 주도 설계>라는 책에서 애그리거트(Aggregate), 밸류 오브젝트(Value Object), 리포지토리(Repository)와 같은 패턴을 제시했다.

이런 패턴들은 **'전술적 도메인 주도 설계(Tactical Domain-Driven Design)'**로 불린다.



## 도메인 모델

도메인 모델 패턴은 복잡한 상태 전환, 비즈니스 규칙과 불변성과 같이 복잡한 비즈니스 로직을 다루기 위한 것이다.

비즈니스 로직에 대한 요구사항은 다양한 규칙 간에 그물 같은 의존성을 형성하고, 모든 규칙은 비즈니스 로직에 영향을 준다.



### 구현

도메인 모델은 **행동(Behavior)과 데이터(Data)** 모두를 포함하는 도메인의 객체 모델이다.

DDD의 전술 패턴인 애그리거트, 밸류 오브젝트, 도메인 이벤트, 도메인 서비스는 모두 객체 모델의 구성요소다.

이 패턴은 비즈니스 로직을 최우선으로 둔다는 공통 관심사가 있다.

#### 복잡성

도메인 비즈니스 로직에 사용되는 객체는 우발적 복잡성을 추가하면 안 된다.

기술적인 관심사를 피해 **플레인 올드 오브젝트(Plain Old Object)**가 되도록 해야 한다.

#### 유비쿼터스 언어

도메인 모델의 객체가 기술적 관심사가 아닌 비즈니스 로직에 집중하게 되면 바운디드 컨텍스트의 유비쿼터스 언어를 따르기 쉬워진다.

이는 도메인 전문가의 멘탈 모델을 따르게 한다.



### 구성 요소

#### 밸류 오브젝트

밸류 오브젝트는 **복합적인(Composition) 값에 의해 식별**되는 객체다.

모든 필드를 통해 객체를 식별하므로 별도 식별자가 필요하지 않다.

**유비쿼터스 언어**

언어의 표준 라이브러리에 포함된 원시 데이터 타입에 의존해서 비즈니스 도메인을 표현하는 것은 원시 집착 코드 징후(Primitive Obsession Code Smell)로 알려져 있다.

이 방식은 유효성 검사 로직이 중복되기 쉽고 값이 사용되기 전에 유효성 검사 로직을 호출하게 하기 어려워 유지보수가 어려워진다.

```java
class Person {
  private int id;
  private String name;
  private String mobilePhone;
  private String email;
}
```

```java
class Person {
  private PersonId id;
  private Name name;
  private PhoneNumber mobile;
  private EmaillAddress email;
}

void main() {
  
}
```

아래와 같은 방식을 이용하면 변수의 의도를 명확하게 전달할 수 있고 값을 할당하기 전에 유효성 검사를 할 필요가 없어진다.

또한 밸류 오브젝트를 조작하는 코드를 한 곳으로 모아 구현하기 쉽고 코드에서 유비쿼터스 언어를 사용하게 되어 **코드에서 비즈니스 도메인의 개념**을 표현하게 된다.

**구현**

밸류 오브젝트는 **불변으로 구현**되므로 필드가 하나라도 바뀌면 다른 값이 생성된다.

몇몇 언어에서 문자열 타입은 밸류 오브젝트로 구현되어 여러 메서드를 내포한 풍부한 동작을 표현할 수 있다.

**밸류 오브젝트를 사용하는 경우**

밸류 오브젝트는 가능한 모든 경우에 사용하는 게 좋다.

비즈니스 도메인 관점에서 다른 객체의 속성을 표현할 때 밸류 오브젝트를 유용하게 사용할 수 있다.

불변이기 때문에 부작용과 동시성 문제가 없고 코드를 응집도 있고 안전하게 해준다.

#### 엔티티

엔티티는 밸류 오브젝트와 달리 다른 인스턴스와 구별하기 위해 **명시적인 식별 필드**가 필요하다.

식별 필드의 핵심 요구사항은 각 엔티티의 인스턴스마다 고유해야 하고 엔티티의 수명주기 내내 불변이어야 한다.

엔티티는 불변이 아니고 값이 변할 수 있고, 엔티티의 속성을 밸류 오브젝트를 통해 설명한다.

엔티티는 모든 **비즈니스 도메인의 필수 구성요소**이며 애그리거트 패턴의 컨텍스트에서만 엔티티를 구현한다.

#### 애그리거트

**애그리거트는 엔티티**이기 때문에 명시적인 식별 필드가 필요하고 인스턴스 수명주기 동안 상태가 변할 수 있다.

하지만 단순한 엔티티가 아닌 **데이터의 일관성을 보호**하는 데 목적이 있다.

**일관성 강화**

애그리거트는 일관성을 강화하는 경계로 애그리거트의 로직은 모든 변경 요청을 검사해서 비즈니스 규칙에 위배되지 않게 해야 한다.

데이터의 일관성을 지키기 위해 애그리거트의 비즈니스 로직을 통해서만 상태를 변경하게 해야 한다.

애그리거트의 퍼블릭 인터페이스로 노출된 **상태 변경 메서드는 '커맨드'**라고 부른다.

커맨드는 애그리거트 객체의 퍼블릭 메서드로 구현하거나 실행에 필요한 모든 입력값을 포함하는 파라미터 객체로 표현할 수 있다.

커맨드는 입력 값의 유효성을 검사하고 비즈니스 규칙과 불변성을 강화하는 것을 담당하므로 모든 비즈니스 로직이 애그리거트 자체에 구현되게 한다.

애그리거트를 저장하는 데이터베이스에서 동시성 관리를 지원해 애그리거트 상태의 일관성을 유지해야 한다.

**트랜잭션 경계**

애그리거트는 트랜잭션 경계의 역할을 하고 애그리거트의 상태 변경은 **트랜잭션 하나당 한 개의 애그리거트**만 가능하다.

이를 통해 애그리거트의 경계가 비즈니스 도메인의 불변성과 규칙을 따르도록 설계하게 된다.

**엔티티 계층**

둘 다 동시에 변경되거나 다른 객체의 상태에 의존하는 등 여러 객체가 하나의 트랜잭션 경계를 공유하는 비즈니스 시나리오가 있을 수 있다.

DDD에서는 애그리거트와 마찬가지로 **비즈니스 도메인이 시스템의 설계를 주도**해야 한다고 규정한다.

애그리거트 패턴은 여러 객체의 변경을 단일 트랜잭션으로 지원하기 위해 엔티티 계층 구조와 유사하게 모든 트랜잭션을 공유해 일관성을 유지한다.

여러 객체가 도메인의 비즈니스 로직 경계 내에 있으면 동일한 애그리거트에 속한다.

애그리거트 패턴은 동일한 트랜잭션 경계에 속한 비즈니스 엔티티와 밸류 오브젝트를 하나로 묶기 때문에 '애그리거트'라고 불린다.

**다른 애그리거트 참조하기**

애그리거트가 너무 커지면 성능과 확장 문제가 생길 수 있다.

애그리거트의 비즈니스 로직에 따라 강력한 일관성이 필요한 정보만 애그리거트에 포함되고 궁극적으로 일관돼도 좋은 정보는 다음과 같이 다른 애그리거트의 일부로 둔다.

![image](https://user-images.githubusercontent.com/80632060/183278381-100983c0-24be-4420-bdd3-72633947a71d.png)

애그리거트를 가능한 한 작게 유지하고 강력하게 일관적으로 상태를 유지해야하는 객체만 포함한다.

그 밖에 애그리거트에 속하지 않는 객체를 ID를 통해 참조함으로써 경계를 명확히 하고 트랜잭션 경계를 보장한다.

궁극적으로 일관된 데이터를 다루는 상황일 때 **시스템의 상태를 손상**시킬 수 있는지 판단해서 엔티티가 애그리거트에 속하는지 판단할 수 있다.

**애그리거트 루트**

애그리거트가 엔티티의 계층 구조를 대표하기 때문에 하나만 애그리거트의 퍼블릭 인터페이스, **애그리거트 루트**로 지정돼야 한다.

모든 커맨드는 애그리거트 루트를 통해서만 접근할 수 있다.

![image](https://user-images.githubusercontent.com/80632060/183278722-6604c61d-1770-4168-a700-5e85fc50712d.png)

애그리거트 루트의 퍼블릭 인터페이스 외에도 외부에서 도메인 이벤트를 통해 애그리거트와 소통할 수 있다.

**도메인 이벤트**

도메인 이벤트는 비즈니스 도메인에서 일어나는 **중요한 이벤트**를 설명하는 메시지다.

도메인 이벤트의 목적은 비즈니스 도메인에서 일어난 일을 설명하고 이벤트와 관련된 모든 필요한 데이터를 제공하는 것이다.

도메인 이벤트는 애그리거트 퍼블릭 인터페이스의 일부로 애그리거트가 자신의 도메인 이벤트를 발행한다.

**유비쿼터스 언어**

코드는 개발자가 다른 개발자 또는 도메인 전문가와 소통할 때 사용하는 것과 동일한 언어를 기반으로 해야 한다.

따라서 애그리거트에 사용되는 모든 용어는 바운디드 컨텍스트의 유비쿼터스 언어로 명명돼야 한다.

#### 도메인 서비스

애그리거트나 밸류 오브젝트에도 속하지 않거나 여러 애그리거트에 관련된 비즈니스 로직을 다룰 때 **도메인 서비스**로 구현할 수 있다.

도메인 서비스는 비즈니스 로직을 구현한 **상태가 없는 객체(Stateless Object)**다.

보통 다양한 출처에서 정보를 필요로 할 때 도메인 서비스로 구현하거나 계산이나 분석을 수행하기 위해 사용한다.

하지만 하나의 트랜잭션에서 하나의 애그리거트만 수정할 수 있는 애그리거트 패턴의 한계를 명심해야 한다.

도메인 서비스는 여러 애그리거트의 인스턴스를 변경하는 것이 아닌 **읽는 것**이 필요한 로직을 구현한다.



### 복잡성 관리

애그리거트와 밸류 오브젝트 패턴은 비즈니스 로직 구현의 복잡성을 다루는 수단으로서 사용된다.

시스템 복잡성을 논의할 때 제어와 동작 예측의 어려움을 평가하는데, 이는 **시스템의 자유도**를 반영한다.

시스템의 자유도는 시스템의 상태를 설명하는 데 필요한 데이터 요소의 개수로 측정된다.

복잡한 것을 불변성으로 감싸서 복잡성을 낮추는 것이 애그리거트와 밸류 오브젝트 패턴이 하는 일이다.

비즈니스 로직은 비즈니스 불변성을 감싸고 보호해서 자유도를 줄인다.

따라서 이는 핵심 하위 도메인에 사용할 수 있다.



## 결론

도메인 모델 패턴은 복잡한 비즈니스 로직을 다루는 데 목적이 있다.

**밸류 오브젝트**

> 값만으로 식별되는 비즈니스 도메인의 개념으로, 명시적인 ID 필드가 필요없다.
>
> 밸류 오브젝트는 불변이며 데이터뿐만 아니라 행동도 모델링한다.

**애그리거트**

> 트랜잭션 경계를 공유하는 엔티티의 계층으로, 애그리거트의 경계에 속하는 모든 데이터는 강력한 일관성을 유지해야 한다.
>
> 애그리거트의 상태와 내부 객체는 커맨드를 실행하여 애그리거트 루트의 퍼블릭 인터페이스를 통해서만 수정될 수 있다.
>
> 애그리거트는 트랜잭션의 경계 역할을 하므로 모든 데이터는 원자적인 단일 트랜잭션으로 커밋돼야 한다.
>
> 애그리거트의 생명주기에서 중요한 비즈니스 이벤트를 설명하는 메시지인 도메인 이벤트를 통해 외부 엔티티와 상호작용할 수 있다.

**도메인 서비스**

> 도메인 모델에서 애그리거트 또는 밸류 오브젝트에 속하지 않는 비즈니스 로직을 담는 상태가 없는 객체다.



# 느낀점

도메인 모델 패턴은 복잡한 비즈니스 로직을 다루기 위해 사용된다는 것을 알게되었다.

도메인 모델의 각 구성요소의 개념, 정의, 경계, 사용되는 곳을 정확하게 알 수 있었다.

- 밸류 오브젝트 - 식별자 필드가 없는 불변인 비즈니스 도메인의 개념
- 애그리거트 - 트랜잭션 경계의 역할을 하고 내부의 모든 데이터의 강력한 일관성을 유지
- 도메인 서비스 - 밸류 오브젝트나 애그리거트가 아니며 상태를 가지지 않는 객체
